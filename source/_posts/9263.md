---
layout: post
title: "[C#]Effective C# 條款二： 運行時常數優於編譯時常數"
date: 2009-07-09 08:46:16
comments: true
tags: [CSharp]
description: "[C#]Effective C# 條款二： 運行時常數優於編譯時常數"
---
<p>
	<img alt="image" border="0" height="280" src="\images\posts\9263\image_thumb_3.png" style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" width="585" /></p>
<p>
	.NET中有兩種不同的常數機制：一種是編譯時(Compile-Time)常數，一種是運行時(Runtime)常數。</p>
<p>
	 </p>
<h2>
	編譯時常數</h2>
<p>
	編譯時常數是透過Const關鍵字宣告的變數，像是如下宣告：</p>
<p>
	public const int BUFFER_SIZE = 512;</p>
<p>
	 </p>
<p>
	編譯時常數故名思義就是編譯時就已被處理的常數，在編譯後會被編譯器替換成該常數值，假設有段程式如下：</p>
<p>
	class Program<br />
	{<br />
	    public const int BUFFER_SIZE = 512;<br />
	    static void Main(string[] args)<br />
	    {<br />
	        byte[] bytes = new byte[BUFFER_SIZE];<br />
	    }<br />
	}</p>
<p>
	 </p>
<p>
	在編譯後，我們可以透過Reflector工具反組譯查看，此時本來使用編譯時常數的地方會被編譯器替換成該變數的值。</p>
<p>
	<img alt="image" border="0" height="541" src="\images\posts\9263\image_thumb.png" style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" width="474" /></p>
<p>
	 </p>
<p>
	編譯時常數雖然在效能方面會比運行時常數好，但在使用彈性上卻不如運行時常數。不僅只能宣告基本型別、列舉型別、與字串型別，別的組件參考使用的話，編譯時變數值也會被編譯器給替換掉。因此若要修改該常數值，除了本身的組件外，也必需將所有參考到的組件都給重新編譯。</p>
<p>
	 </p>
<h2>
	運行時常數</h2>
<p>
	運行時常數是透過readonly關鍵字聲明的變數，像是如下宣告：</p>
<p>
	public static readonly int BUFFER_SIZE = 512;</p>
<p>
	 </p>
<p>
	運行時常數故名思義就是在運行中才可使用的常數，該常數值在運行時才會被計算，編譯後並不會被編譯器替換常數值，因此在使用上彈性優於編譯時常數。若要修改常數的值，所有參考使用的組件都不需配合重新編譯。也不像編譯時常數一樣有型別上的限制。</p>
