---
layout: post
title: "[.Net Concept].Net automatic bitness feature"
date: 2011-06-17 08:40:32
comments: true
tags: [.NET Concept]
description: "[.Net Concept].Net automatic bitness feature"
---
<p />  <p>相信大家在開發時都曾注意到過在專案屬性頁面之中，有個跟位元有關的編譯設定，其預設值為Any CPU。</p>  <p><img style="border-bottom: 0px; border-left: 0px; border-top: 0px; border-right: 0px" border="0" alt="image" src="\images\posts\28955\image_thumb.png" width="364" height="43" /> </p>  <p> </p>  <p>在大多數的情況下，我們不需要更改其設定值。因為這樣的設定會讓我們的程式享有.Net程式的Automatic bitness(自動位元適應)特性，可讓我們的應用程式能夠自動適應不同位元環境，在不同位元的環境之下都能正常運作。</p>  <p>   <br />雖然Automatic bitness特性讓我們的應用程式具有很好的位元適應性，但有的時候我們又不得不將之捨棄。像是應用程式使用到依存於32位元的組件時，我們的應用程式因為運行於64位元的環境，應用程式被切換為64位元應用程式，讓依存於32位元的組件發生錯誤，整個程式因此無法正常運行。此時我們就必需修改此編譯設定，將其設為x86，強制應用程式以32位元運行。</p>  <p>   <br />除了參考到依存於32位元的組件外，若是在程式的撰寫時對於位元環境有過多的假設，也會讓程式無法享有Automatic bitness特性。像是錯誤的指標大小假設，這多半發生於撰寫平台叫用時，很多開發人員會將該宣告為IntPtr型態的參數設為Int型態。這會讓應用程式在32位元的環境下運作正常，但在64位元環境下運作就會發生問題。像筆者就曾看過因為型態宣告不當而造了兩個CopyDataStruct的狀況，一個用於32位元環境(使用Int32)，一個用於64位元環境(使用Int64)，接收訊息時再去判斷指標大小導到對應的處理，雖然這樣勉強能同時適應於32與64位元環境，但整個程式也因此變得龐雜。</p>