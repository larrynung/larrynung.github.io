---
layout: post
title: "[C#]Effective C# 條款九： 理解幾個相等判斷之間的關係"
date: 2009-10-21 08:27:25
comments: true
tags: [CSharp]
description: "[C#]Effective C# 條款九： 理解幾個相等判斷之間的關係"
---
<p>
	C#提供了四種不同的函式來判斷兩個物件是否相等：</p>
<p>
	1.ReferenceEquals靜態方法</p>
<div class="wlWriterEditableSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:fe419669-a6a3-4f8c-b784-3d56c3128da1" style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px">
	<pre class="c#:nocontrols" name="code">
	public static bool ReferenceEquals(object left, object right);</pre>
</div>
<p>
	 </p>
<p>
	2.Equals靜態方法</p>
<div class="wlWriterEditableSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:328eb2b2-3db6-4bb5-9e11-07b176b1a805" style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px">
	<pre class="c#:nocontrols" name="code">
	public static bool Equals(object left,object right);</pre>
</div>
<p>
	 </p>
<p>
	3.Equals方法</p>
<div class="wlWriterEditableSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:efcf644f-5b6a-458d-9b6d-7257e0554074" style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px">
	<pre class="c#:nocontrols" name="code">
	public virtual bool Equals(object right);</pre>
</div>
<p>
	 </p>
<p>
	4.運算子==</p>
<div class="wlWriterEditableSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:4da3cba7-b97f-4084-b440-61e68f8d38a6" style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px">
	<pre class="c#:nocontrols" name="code">
	public static bool operator== (MyClass object,MyClass right);</pre>
</div>
<p>
	 </p>
<p>
	前兩個靜態方法我們永遠都不應該去重新定義，後兩個則可視需要去重新定義。</p>
<p>
	 </p>
<p>
	以ReferenceEquals來說，其功能為判斷兩個變數指標是否指向同一物件。也就是判斷兩者的物件參考是否相同。如果兩個指標所指的是同一物件的話，則該方法會返回True值。反之，則傳回False。若是以值類別來看，以ReferenceEquals來比較兩個值類別。或是將一個值類別與自身進行比較。其值皆為False。對於ReferenceEquals來說，.預設的功能已經把該方法該有的功能做得很好了，因此我們不需要對此重新定義。</p>
<p>
	 </p>
<p>
	而Object.Equals靜態方法則是當我們不知道執行階段類型時，所採用的判斷相等的方法。其實現概念如下：</p>
<div class="wlWriterEditableSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:da14efd3-7b51-4af6-b50e-f226f50d929b" style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px">
	<pre class="c#:nocontrols" name="code">
	public static bool Equals(object left, object right)
{
    //兩個物件參考相等=&gt;return true;
    if (left == right)
        return true;

    //兩個有一個為空=&gt;return false;
    if ((left == null) || (right == null))
        return false;

    //透過left.Equals判斷是否相等
    return left.Equals(right);
}</pre>
</div>
<p>
	 </p>
<p>
	從上述代碼可以看出，當傳入相同的物件參考，該方法會回傳True。而當物件參考不同時，Object.Equals靜態方法會透過叫用left參數的Equals方法來做相等判斷。該方法預設在功能上已經做得很好了，我們也不需對此重新定義。</p>
<p>
	 </p>
<p>
	至於非靜態的Object.Equals方法，當預設的處理方式與我們所預期的不同，可以視需求重新定義。像是値類型在預設的情況下，其Equals方法是叫用基底類別ValueType.Equals來處理的。判斷的動作是在不知道類別成員的狀態下去做的。因此，它是利用.NET的反射機制來達到對應的效果，在效能上的表現並不是很好。所以當建立值類別時，我們都應重新定義ValueType.Equals方法。而另一個需重新定義的情況是，當參考類別不想採用物件參考來判斷是否相等，想改用值類型的判斷方式時，我們也可以重新定義Object.Equals方法。</p>
<p>
	 </p>
<p>
	Object.Equals方法若要重新定義，一般可以遵循下列的順序來實作：<br />
	<img alt="image" border="0" height="62" src="\images\posts\11168\image_thumb_1.png" style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" width="477" /></p>
<p>
	 </p>
<p>
	程式碼實作上會如下：<br />
	 </p>
<div class="wlWriterEditableSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:eca22365-f366-4d4f-9e6b-59cb2fdec2e9" style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px">
	<pre class="c#:nocontrols" name="code">
	public override bool Equals(object obj)
        {
            //檢查參數是否為null
            if (obj == null)
                return false;

            //檢查是否與自身是相同物件
            if (object.ReferenceEquals(this, obj))
                return true;

            //檢查是否型態相等
            if (this.GetType() != obj.GetType())
                return false;

            //比較內容是否相等
            return CompareMembers(this, obj);
        }</pre>
</div>
<p>
	 </p>
<p>
	 </p>
<p>
	若重新定義的類別其Equals方法不是由System.Object或是System.ValueType提供的話，其實作流程會變為下面這樣：<a href="http://files.dotblogs.com.tw/larrynung/0910/CEffectiveC_14B77/image_8.png" rel="lightbox"><br />
	<img alt="image" border="0" height="62" src="\images\posts\11168\image_thumb_3.png" style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" width="578" /></a></p>
<p>
	 </p>
<p>
	程式碼實作上會如下：<br />
	 </p>
<div class="wlWriterEditableSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:0c353c3c-51aa-4f73-bfe5-659e767b5c4e" style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px">
	<pre class="c#:nocontrols" name="code">
	public override bool Equals(object obj)
        {
            //檢查參數是否為null
            if (obj == null)
                return false;

            //檢查是否與自身是相同物件
            if (object.ReferenceEquals(this, obj))
                return true;

            //檢查是否型態相等
            if (this.GetType() != obj.GetType())
                return false;

            //叫用基底類別的Equals方法
            if(!base.Equals(obj))
                return false;

            //比較內容是否相等
            return CompareMembers(this, obj);
        }</pre>
</div>
<p>
	 </p>
<p>
	值得注意的是，當我們重新定義了Equals方法時，GetHashCode方法也要跟著重新定義，如此該類別在雜湊函式才可正常運作。</p>
<p>
	 </p>
<p>
	最後一個Operator==，則是當我們建立值類別時，就應該重新定義。其理由跟上面重新定義ValueType.Equals方法的一樣。</p>
