---
layout: post
title: "[C#]Effective C# 條款三： 運算子is或as優於強制轉型"
date: 2009-09-30 08:17:52
comments: true
tags: [CSharp]
description: "[C#]Effective C# 條款三： 運算子is或as優於強制轉型"
---
<p>
	對C#而言，在做型別轉換時，撇開一些型別有提供Parse可供轉型外，通常我們有兩種選擇：一種是利用as運算子、一種則是強制轉型。作型別轉換時，應盡量採用as運算子來做轉型的動作，因為它比強制轉型安全，也具有較好的效能。</p>
<p>
	這邊讓我們直接來看個例子。假設今天我們寫一段程式，需將Object轉型為MyType。我們可以使用as運算子處理：</p>
<div class="wlWriterEditableSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:871e637a-cfd6-4ad3-a3c8-08a4a45b8b3f" style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px">
	<pre class="c#:nocontrols" name="code">
	object o = Factory.GetObject();
            MyType t = o as MyType;
            if(t != null)
            {
                //轉型成功
            }else{
                //轉型失敗
            }</pre>
</div>
<p>
	 </p>
<p>
	 </p>
<p>
	也可以使用強制轉型來做：</p>
<div class="wlWriterEditableSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:b28de273-a60b-4e77-80da-5e7dc0dd9542" style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px">
	<pre class="c#:nocontrols" name="code">
	try
            {
                object o = Factory.GetObject();
                MyType t = (MyType)o;
                if (t != null)
                {
                    //轉型成功
                }
                else
                {
                    //Null
                }
            }
            catch
            {
                //轉型失敗
            }</pre>
</div>
<p>
	 </p>
<p>
	 </p>
<p>
	 </p>
<p>
	很明顯的，使用as運算子來做轉型，程式會較為簡單易讀，不需添加例外處理，在效能上自然也不會有額外的負擔。強制轉型在使用上除了需作例外處理，也需外加null的判斷(主要是因為null可轉為任意型態)。而as運算子轉型就只需要檢查轉型後是否為null即可。</p>
<p>
	as運算子只能用於參考類型，不能應用於值類型(除非是Nullable的值類型)。像下面的程式就無法通過編譯器的編譯：</p>
<div class="wlWriterEditableSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:653e4953-9a30-4592-882c-c07f30c24411" style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px">
	<pre class="c#:nocontrols" name="code">
	object o = Factory.GetObject();
            int i = o as int;</pre>
</div>
<p>
	 </p>
<p>
	這是因為值類型不可為null導致(因若o無法轉型為整數，值類型也不可為null，其值無從填入i)。像這樣的值類型轉換，我們就可以使用強制轉型來處理：</p>
<div class="wlWriterEditableSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:b099ce6b-5f52-4a34-b0da-6a132d4bc8e8" style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px">
	<pre class="c#:nocontrols" name="code">
	object o = Factory.GetObject();
            int i = 0;
            try
            {
                i = (int)o;
            }catch { 
                //轉型失敗
            }</pre>
</div>
<p>
	 </p>
<p>
	好一點的寫法，可以搭配is運算子來避免異常的發生</p>
<div class="wlWriterEditableSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:39f56b6b-87ae-4712-a6c4-01b96c08e6d5" style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px">
	<pre class="c#:nocontrols" name="code">
	object o = Factory.GetObject();
            int i = 0;
            if (o is int)
                i = (int)o;</pre>
</div>
<p>
	 </p>
<p>
	一般來說只有當不能使用as運算子作轉型動作時，才會考慮使用is運算子，不然多半會產生冗餘的程式碼。像是：</p>
<div class="wlWriterEditableSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:901c4986-ad7b-48d3-8d01-83301b65c566" style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px">
	<pre class="c#:nocontrols" name="code">
	object o = Factory.GetObject();
            MyType t = null;
            if (o is MyType)
                t = o as MyType;</pre>
</div>
<p>
	 </p>
<p>
	 </p>
<p>
	由上述，我們可以得知，在型別轉換的抉擇上，最好遵循著一個順序：</p>
<p>
	<img alt="image" border="0" height="64" src="\images\posts\10834\image_thumb_1.png" style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" width="387" /></p>
<p>
	值得一提的是，我們常用的foreach語法，由於要同時支援值類型與參考類型，內部的轉型是採用強制轉型，若轉型失敗會產生InvalidCastException例外。</p>
