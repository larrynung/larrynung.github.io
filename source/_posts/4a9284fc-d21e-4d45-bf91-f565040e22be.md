---
layout: post
title: "[C#]使用Mutex實現單一程式執行個體的注意事項"
date: 2013-11-06 12:00:00
comments: true
tags: [CSharp]
description: "[C#]使用Mutex實現單一程式執行個體的注意事項"
---
<p>
	相信大家都知道在.NET程式中若要實現單一程式執行個體，一般來說有幾種方法，像是去判斷是否已經有開啟的Process是相同的程式、用Mutex與Semaphore之類的技術來判斷是否程式正在開啟。但是很多網路上的文章都忽略了在用Mutex實現單一程式執行個體時，其實會有些必須要注意的地方，導致於在實際運用上沒有發揮到該有的效果。</p>
<p>
	 </p>
<p>
	以一個簡單的例子來看，一般我們在網路上常看到的使用方式大概就像下面的程式碼片段類似，建構Mutex時就會回傳該Mutex是否已經存在，利用該回傳值來決定程式應該繼續開啟還是關閉。</p>
<div class="wlWriterSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:cb281f4a-96c4-43f8-bd59-3cdd34c31203" style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px">
	<pre class="c" name="code">
using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows.Forms;
using System.Threading;

namespace WindowsFormsApplication10
{
	static class Program
	{
		/// &lt;summary&gt;
		/// The main entry point for the application.
		/// &lt;/summary&gt;
		[STAThread]
		static void Main()
		{
			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);

			Boolean bCreatedNew;

			//Create a new mutex using specific mutex name
			Mutex m = new Mutex(false, "myUniqueName", out bCreatedNew);

			if (bCreatedNew)
				Application.Run(new Form1());
		}
	}
}</pre>
</div>
<p>
	 </p>
<p>
	這樣的程式到底有什麼樣的問題呢？有興趣的可以試著建置Release的程式看看，其實這樣的程式在某些情況下會在Release模式下失效，Debug的運作卻是正常的，若試不出來的可以再加上個GC.Collect試試，會更容易重現。</p>
<div class="wlWriterSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:20c74bd4-3d1e-4d4b-a26c-b57e226af0e2" style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px">
	<pre class="c#" name="code">
			...
			Boolean bCreatedNew;

			//Create a new mutex using specific mutex name
			Mutex m = new Mutex(false, "myUniqueName", out bCreatedNew);

			GC.Collect();

			if (bCreatedNew)
				Application.Run(new Form1());
			...</pre>
</div>
<p>
	 </p>
<p>
	之所以會有這樣的問題，是因為Mutex在Release模式下被GC給回收了，而Debug模式下因為便於開發人員除錯，據說有將GC的周期給拉長，所以不容易重現。那這樣的問題要怎麼樣解決呢？這邊筆者有整理了幾種方法。</p>
<p>
	 </p>
<p>
	一個方法就是把Mutex給拉出來成為類別成員。</p>
<div class="wlWriterSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:bfaa1b40-dd19-4002-924a-c226b4524ff1" style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px">
	<pre class="c#" name="code">
		...
		static Mutex m;

		/// &lt;summary&gt;
		/// The main entry point for the application.
		/// &lt;/summary&gt;
		[STAThread]
		static void Main()
		{
			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);

			Boolean bCreatedNew;

			//Create a new mutex using specific mutex name
			m = new Mutex(false, "myUniqueName", out bCreatedNew);
			GC.Collect();

			if (bCreatedNew)
				Application.Run(new Form1());
		}
		...</pre>
</div>
<p>
	 </p>
<p>
	另一個方法就是讓Mutex不要被GC回收掉，像是在程式最後明確呼叫Dispose，讓GC知道該Mutex仍在使用。</p>
<div class="wlWriterSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:d5b96c79-a2fa-4b33-aa8c-3d9aca1cc9b4" style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px">
	<pre class="c#" name="code">
			...
			Boolean bCreatedNew;

			//Create a new mutex using specific mutex name
			Mutex m = new Mutex(false, "myUniqueName", out bCreatedNew);

			GC.Collect();

			if (bCreatedNew)
				Application.Run(new Form1());

			m.Dispose();
			...</pre>
</div>
<p>
	 </p>
<p>
	也可以用using或是try...finally之類的語法將Mutex給hold住。</p>
<div class="wlWriterSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:d3de0313-0833-4b8c-8da7-1c8a5dc4e64a" style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px">
	<pre class="c#" name="code">
			...
			Boolean bCreatedNew;

			//Create a new mutex using specific mutex name
			using (Mutex m = new Mutex(false, "myUniqueName", out bCreatedNew))
			{
				GC.Collect();

				if (bCreatedNew)
					Application.Run(new Form1());
			}
			...</pre>
</div>
<p>
	 </p>
<p>
	或是把Mutex的用法寫的比較正規一點，加上WaitOne與ReleaseMutex去明確控制Mutex的作用範圍。</p>
<div class="wlWriterSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:acd4b55e-cca3-4c62-8cd1-825561a57d57" style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px">
	<pre class="c#" name="code">
			...
			Boolean bCreatedNew;

			//Create a new mutex using specific mutex name
			Mutex m = new Mutex(false, "myUniqueName", out bCreatedNew);

			m.WaitOne();
			GC.Collect();

			if (bCreatedNew)
				Application.Run(new Form1());

			m.ReleaseMutex();
			...</pre>
</div>
<p>
	 </p>
<h2>
	Link</h2>
<ul>
	<li>
		C#,利用Mutex實現應用程式的單實例運行</li>
	<li>
		[C#] 避免重複開啟應用程式</li>
	<li>
		[C#/VB.net] 一次只執行一個WinForm視窗程式</li>
	<li>
		如何避免相同的 ConsoleApp 或 WinForm 同時間重複執行</li>
	<li>
		[C#.NET][VB.NET][VB6] 如何禁止程式重覆執行 / System.Threading.Mutex &amp; Semaphore</li>
	<li>
		单实例程序 互斥进程 Mutex Debug VS Release 运行不一样</li>
	<li>
		Mutex is different in debug model and release model?</li>
	<li>
		Mutex实现单实例，你真的搞懂了吗？来看看吧。</li>
</ul>
