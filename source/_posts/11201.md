---
layout: post
title: "[C#]Effective C# 條款十一： 優先採用foreach迴圈"
date: 2009-10-22 08:41:07
comments: true
tags: [C#]
description: "[C#]Effective C# 條款十一： 優先採用foreach迴圈"
---
<p>
	C#中的foreach迴圈並不僅僅是do…while或是for迴圈的變形。它會與.NET框架中的集合接口做緊密的結合，在編譯時為我們最佳化程式碼。除此之外foreach使用上也具備較高的相容性。</p>
<p>
	 </p>
<p>
	讓我們先來看三種迴圈的寫法：</p>
<p>
	1.foreach迴圈寫法<br />
	 </p>
<div class="wlWriterEditableSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:d6aa70c4-44c5-4a5e-bb78-30ea411e7132" style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px">
	<pre class="c#:nocontrols" name="code">
	int[] foo = new int[100];
foreach(int i in foo)
    Console.WriteLine(i.ToString());</pre>
</div>
<p>
	 </p>
<p>
	 </p>
<p>
	2.for迴圈寫法</p>
<div class="wlWriterEditableSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:a0c74d01-61eb-458c-b3e8-ce233eb04f39" style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px">
	<pre class="c#:nocontrols" name="code">
	int[] foo = new int[100];
for(int index=0;index&lt;foo.Length;index++)
    Console.WriteLine(foo[index].ToString());</pre>
</div>
<p>
	 </p>
<p>
	3.for迴圈寫法 (結束條件提到迴圈外)</p>
<div class="wlWriterEditableSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:def77ae4-2f47-4be0-94dd-4b49044c1ed8" style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px">
	<pre class="c#:nocontrols" name="code">
	int[] foo = new int[100];
int len = foo.Length;
for(int index=0;index&lt;len;index++)
    Console.WriteLine(foo[index].ToString());</pre>
</div>
<p>
	 </p>
<p>
	據作者所述，第一個迴圈的寫法，在.NET1.1以後的版本，其效率最佳，程式碼也最少。而第三個迴圈寫法是最慢的，因為這樣刻意的把結束條件提出迴圈外，會阻礙JIT編譯器移除迴圈內的範圍檢查，讓JIT編譯器編譯成下面這樣：</p>
<div class="wlWriterEditableSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:8358443f-c8fc-4746-82a9-9e8625c3233d" style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px">
	<pre class="c#:nocontrols" name="code">
	int[] foo = new int[100];
int len = foo.Length;
for(int index=0;index&lt;len;index++){
    if(index&lt;foo.Length)
        Console.WriteLine(foo[index].ToString());
    else
        throw new IndexOutOfRangeException();
}</pre>
</div>
<p>
	 </p>
<p>
	在.NET 1.0以前，使用foreach效率上會較差，因為JIT編譯器會把程式編譯成下面這樣：</p>
<div class="wlWriterEditableSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:c362989a-77e4-4e09-b280-bcf0a02bfd80" style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px">
	<pre class="c#:nocontrols" name="code">
	IEnumerator it = foo.GetEnumerator();
while(it.MoveNext())
{
   int i = (int) it.Current;
   Console.WriteLine(i.ToString());
}</pre>
</div>
<p>
	 </p>
<p>
	這樣的程式會產生裝箱與拆箱，因此在效能上會有不良的影響。但在.NET 1.1以後的版本，JIT編譯器會把程式編譯成下面這樣：</p>
<div class="wlWriterEditableSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:dc3ddc35-c582-42a9-8ef2-8a04981223d9" style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px">
	<pre class="c#:nocontrols" name="code">
	int[] foo = new int[100];
for(int index=0;index&lt;foo.Length;index++)
    Console.WriteLine(foo[index].ToString());</pre>
</div>
<p>
	 </p>
<p>
	 </p>
<p>
	所以我們可以得知，使用foreach來處理迴圈，編譯器會幫我們自動產生最佳的程式碼，程式也較短較易閱讀。</p>
<p>
	 </p>
<p>
	不過經實際實驗，當撰寫了如下測試程式：</p>
<div class="wlWriterEditableSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:2db0b84e-fa16-473a-886b-a1aef45fdcf0" style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px">
	<pre class="c#:nocontrols" name="code">
	static void Main(string[] args)
        {
            int[] foo = new int[100];
            int len = foo.Length;

            foreach (int i in foo)
                Console.WriteLine(i.ToString());

            for (int index = 0; index &lt; len; index++)
                Console.WriteLine(foo[index].ToString());

            for (int index = 0; index &lt; foo.Length; index++)
                Console.WriteLine(foo[index].ToString());
        }</pre>
</div>
<p>
	 </p>
<p>
	用Reflector反組譯工具來查看，該段程式被編譯後是幾乎不變的。</p>
<p>
	<img alt="image" border="0" height="306" src="\images\posts\11201\image_thumb.png" style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" width="277" /></p>
<p>
	 </p>
<p>
	這邊就留待個人自己去評估。</p>
<p>
	 </p>
<p>
	除效能外，foreach迴圈在使用上也具備較高的相容性。不論巡覽的陣列其上下限是多少，foreach迴圈總是能正確的運行。在多維陣列上，不論陣列維度維多少，使用foreach迴圈都能幫我們巡覽所有陣列元素。就算本來使用的是陣列，後來因需求變更為使用集合類別，使用foreach迴圈，程式都不需做任何的修改。</p>
<p>
	 </p>
<p>
	綜合以上論點，在撰寫巡覽迴圈元素的程式時，我們應該優先考慮使用foreach迴圈寫法。因其可獲得較好的效能與較高的相容性，也可提升開發速度與可讀性。</p>
