---
layout: post
title: "[.NET Concept]throw V.S throw ex"
date: 2011-01-03 06:58:32
comments: true
tags: [C#,.NET Concept]
description: "[.NET Concept]throw V.S throw ex"
---
<p>在例外處理時，有些情況下我們會需要將例外攔截後再次向外擴，在此時我們有兩種可選擇的寫法，一種是很多初學者會採用的透過throw ex來外擴例外，這種寫法須避免使用，因為採用此種寫法會改變的原來的呼叫堆疊，造成除錯上的困難。</p>  <div class="wlWriterSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:a90b3f59-2391-4602-9cd6-8113dc25b0fe" style="padding-right: 0px; display: inline; padding-left: 0px; float: none; padding-bottom: 0px; margin: 0px; padding-top: 0px"><pre name="code" class="c#">    try
    {
        // do something
    }
    catch (Exception ex)
    {
        // do something
        throw ex;
    }</pre></div>

<p> </p>

<p />
另一種則是直接透過throw來外擴，跟throw ex不同的是，採用這種方法在外擴例外的同時仍可保留原有的呼叫堆疊。

<div class="wlWriterSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:de72fd25-7be7-44c4-9673-7be64bcd2d13" style="padding-right: 0px; display: inline; padding-left: 0px; float: none; padding-bottom: 0px; margin: 0px; padding-top: 0px"><pre name="code" class="c#">    try
    {
        // do something
    }
    catch (Exception ex)
    {
        // do something
        throw;
    }</pre></div>

<p> </p>

<p>這邊來看個較為完整的範例：</p>

<div class="wlWriterSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:e8199619-8602-4177-ba68-a87425c37cd5" style="padding-right: 0px; display: inline; padding-left: 0px; float: none; padding-bottom: 0px; margin: 0px; padding-top: 0px"><pre name="code" class="c#">using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;

namespace ConsoleApplication6
{
    class Program
    {

        static void Main()
        {
            TestThrow();
            TestThrowEx();
        }


        static void ThrowException()
        {
            throw new Exception();
        }

        static void TestThrow()
        {
            try
            {
                try
                {
                    ThrowException();
                }
                catch (Exception)
                {
                    throw;
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("TestThrow");
                Console.WriteLine(ex.StackTrace);
                Console.WriteLine(new string('=',50));
            }
        }


        static void TestThrowEx()
        {
            try
            {
                try
                {
                    ThrowException();
                }
                catch (Exception ex)
                {
                    throw ex;
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("TestThrowEx");
                Console.WriteLine(ex.StackTrace);
                Console.WriteLine(new string('=', 50));
            }
        }

    }
}</pre></div>

<p> </p>

<p>其運行結果如下：</p>

<p><img style="border-top-width: 0px; border-left-width: 0px; border-bottom-width: 0px; border-right-width: 0px" height="299" alt="Image" src="\images\posts\20548\Image_thumb.png" width="465" border="0" /></p>

<p> </p>

<p>從運行結果我們可以看出直接呼叫throw外擴例外的方法，其呼叫堆疊仍舊保留有外擴前的呼叫堆疊資訊，而呼叫throw ex外擴例外的方法，則只剩下外擴後的呼叫堆疊，外擴前的呼叫堆疊資訊會被覆寫掉，透過呼叫堆疊只能追到外擴的點，看不到例外發生的源頭，造成後續我們使用呼叫堆疊去找尋錯誤的困難。</p>

<p> </p>

<h2>Link</h2>

<ul>
  <li>Coding Standard (一)：錯誤處理小技巧 </li>

  <li>Re-throwing exceptions - a subtle difference between Java and .NET you better be aware of </li>

  <li>throw 和 throw ex 的差別 </li>
</ul>